--
-- Role-based User Management System
-- Revised: Role-based access control for admin and user dashboards
--

-- Custom types
create type public.app_permission as enum ('admin.access', 'superadmin.access');
create type public.app_role as enum ('user', 'admin', 'superadmin');

-- USERS TABLE - Profile table extending auth users
create table public.users (
  id          uuid references auth.users not null primary key, -- UUID from auth.users
  email       text not null,
  first_name  text,
  last_name   text,
  company     text,
  role        app_role default 'user'::public.app_role not null,
  created_at  timestamp with time zone default timezone('utc'::text, now()) not null,
  updated_at  timestamp with time zone default timezone('utc'::text, now()) not null
);
comment on table public.users is 'User profile information and roles.';
comment on column public.users.id is 'Supabase Auth user reference.';
comment on column public.users.role is 'User role: user, admin, superadmin.';

-- ROLE PERMISSIONS TABLE
create table public.role_permissions (
  id           bigint generated by default as identity primary key,
  role         app_role not null,
  permission   app_permission not null,
  unique (role, permission)
);
comment on table public.role_permissions is 'Application permissions for each role.';

-- Insert default permissions
insert into public.role_permissions (role, permission) values
  ('admin', 'admin.access'),
  ('superadmin', 'admin.access'),
  ('superadmin', 'superadmin.access');

-- Authorization function for admin access
create function public.authorize(
  requested_permission app_permission
)
returns boolean as $$
declare
  user_role_var app_role;
  bind_permissions int;
begin
  -- Get user's role
  select role into user_role_var
  from public.users
  where id = auth.uid();
  
  -- Return false if user not found
  if user_role_var is null then
    return false;
  end if;
  
  -- Check permission
  select count(*)
  from public.role_permissions
  where role_permissions.permission = authorize.requested_permission
    and role_permissions.role = user_role_var
  into bind_permissions;
  
  return bind_permissions > 0;
end;
$$ language plpgsql security definer set search_path = public;

-- Drop old admin functions first (before creating new ones)
-- Use CASCADE to drop dependent objects (like RLS policies)
drop function if exists is_admin(uuid) cascade;
drop function if exists is_superadmin(uuid) cascade;
drop function if exists has_admin_access() cascade;
drop function if exists has_superadmin_access() cascade;

-- Helper functions for admin access
create function public.has_admin_access()
returns boolean as $$
begin
  return authorize('admin.access');
end;
$$ language plpgsql security definer set search_path = public;

create function public.has_superadmin_access()
returns boolean as $$
begin
  return authorize('superadmin.access');
end;
$$ language plpgsql security definer set search_path = public;

-- Secure the tables
alter table public.users enable row level security;
alter table public.role_permissions enable row level security;

-- RLS policies for users table
create policy "Public read access" on public.users 
  for select using ( auth.role() = 'authenticated' );

create policy "Own profile update" on public.users 
  for update using ( auth.uid() = id );

create policy "Admin full access" on public.users 
  for all using ( has_admin_access() );

-- RLS policies for role permissions  
create policy "Admin role permissions read" on public.role_permissions 
  for select using ( has_admin_access() );

-- Set replica identity
alter table public.users replica identity full;

-- Function to handle new user creation and add to users table
create function public.handle_new_user() 
returns trigger as $$
declare 
  is_first_user boolean;
begin
  -- Check if this is the first user
  select count(*) = 0 from auth.users into is_first_user;
  
  -- Insert into users table
  insert into public.users (id, email, first_name, last_name, role)
  values (
    new.id, 
    new.email,
    coalesce(new.raw_user_meta_data->>'first_name', split_part(new.email, '@', 1)),
    coalesce(new.raw_user_meta_data->>'last_name', ''),
    case 
      -- First user becomes superadmin
      when is_first_user then 'superadmin'::app_role
      -- Email contains +admin becomes admin
      when position('+admin@' in new.email) > 0 then 'admin'::app_role
      -- Email contains +superadmin becomes superadmin  
      when position('+superadmin@' in new.email) > 0 then 'superadmin'::app_role
      -- Default to user
      else 'user'::app_role
    end
  );
  
  return new;
end;
$$ language plpgsql security definer set search_path = auth, public;

-- Create trigger
create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

-- Migrate data from existing admins table and drop it
do $$
declare
  admin_record record;
begin
  -- Transfer admin users from existing admins table to users table
  if exists (select 1 from information_schema.tables where table_name = 'admins') then
    for admin_record in 
      select a.user_id, a.role, u.email 
      from admins a 
      join auth.users u on a.user_id = u.id 
    loop
      -- Insert or update in users table
      insert into public.users (id, email, role)
      values (
        admin_record.user_id, 
        admin_record.email,
        admin_record.role::app_role
      )
      on conflict (id) do update set
        role = admin_record.role::app_role;
    end loop;
    
    -- Drop old admins table
    drop table if exists admins cascade;
  end if;
end $$;

-- Only update admin policies that were created by previous migrations
-- This preserves existing user policies and only updates admin access
do $$
declare
    table_record record;
begin
    for table_record in 
        select table_name 
        from information_schema.tables 
        where table_schema = 'public' 
        and table_type = 'BASE TABLE'
        and table_name not in ('users', 'role_permissions') -- These tables are already configured
    loop
        -- Only drop and recreate admin policies that match our old naming convention
        -- This preserves other existing policies
        execute format('drop policy if exists "Admin access" on %I', table_record.table_name);
        
        -- Only create new admin policy if there isn't already one with a different name
        -- Check if there's already an admin policy
        if not exists (
            select 1 from pg_policies 
            where tablename = table_record.table_name 
            and schemaname = 'public'
            and policyname like '%admin%'
            and policyname != 'Admin access'
        ) then
            execute format('
                create policy "Admin full access" on %I
                for all
                to authenticated
                using (has_admin_access())
            ', table_record.table_name);
        end if;
    end loop;
end $$;

/**
 * REALTIME SUBSCRIPTIONS
 * Enable realtime only for necessary tables
 */
begin; 
  -- Drop existing publication
  drop publication if exists supabase_realtime; 
  -- Create new publication
  create publication supabase_realtime;  
commit;

-- Add users table to publication
alter publication supabase_realtime add table public.users;
